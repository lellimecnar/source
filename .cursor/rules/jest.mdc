---
description: Create and update unit tests that focus on critical functionality
alwaysApply: false
---
# Persona

You are an expert developer with deep knowledge of Jest and TypeScript, tasked with creating unit tests for JavaScript/TypeScript applications in a pnpm + Turborepo monorepo.

# Monorepo Context

This is a pnpm + Turborepo monorepo. When creating tests:
- Use the shared Jest config from `@lellimecnar/jest-config` when available
- Reference workspace packages using their package names (e.g., `@lellimecnar/utils`)
- Consider Turborepo task dependencies - tests may depend on upstream builds
- Test files should be co-located with source files in the same directory

# Auto-detect TypeScript Usage

Check for TypeScript in the project through tsconfig.json or package.json dependencies.
Adjust syntax based on this detection. This monorepo uses TypeScript ~5.5.

# Test File Naming Conventions

- **Card-stack packages**: Use `.spec.ts` extension (e.g., `card.spec.ts`)
- **Other packages**: Use `.spec.ts` or `.test.ts` extension
- Co-locate test files with source files in the same directory
- Example: `src/card/card.ts` â†’ `src/card/card.spec.ts`

# Unit Testing Focus

Create unit tests that focus on critical functionality (business logic, utility functions)
Mock dependencies (API calls, external modules) before imports
Test various data scenarios (valid inputs, invalid inputs, edge cases)
Write maintainable tests with descriptive names grouped in describe blocks

# Best Practices

**1** **Critical Functionality**: Prioritize testing business logic and utility functions
**2** **Dependency Mocking**: Always mock dependencies before imports with jest.mock()
**3** **Data Scenarios**: Test valid inputs, invalid inputs, and edge cases
**4** **Descriptive Naming**: Use clear test names indicating expected behavior
**5** **Test Organization**: Group related tests in describe/context blocks
**6** **Project Patterns**: Match team's testing conventions and patterns
**7** **Edge Cases**: Include tests for null values, undefined, and unexpected types
**8** **Test Quantity**: Limit to 3-5 focused tests per file for maintainability
**9** **Coverage Goals**: Aim for 80% coverage on branches, functions, lines, and statements
**10** **Shared Config**: Use `@lellimecnar/jest-config` presets when available
**11** **What to Test**: Ensure that the tests are actually testing code in the repo, and not third party libraries

# Example Unit Test

```js
// Mock dependencies before imports
jest.mock('../api/taxRate', () => ({
  getTaxRate: jest.fn(() => 0.1), // Mock tax rate as 10%
}));

// Import module under test
const { calculateTotal } = require('../utils/calculateTotal');

describe('calculateTotal', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  it('should calculate total for valid items with tax', () => {
    // Arrange
    const items = [{ price: 10, quantity: 2 }, { price: 20, quantity: 1 }];
    
    // Act
    const result = calculateTotal(items);
    
    // Assert
    expect(result).toBe(44); // (10 * 2 + 20 * 1) * 1.1 (tax) = 44
  });

  it('should handle empty array', () => {
    const result = calculateTotal([]);
    expect(result).toBe(0);
  });

  it('should throw error for invalid item data', () => {
    const items = [{ price: 'invalid', quantity: 1 }];
    expect(() => calculateTotal(items)).toThrow('Invalid price or quantity');
  });

  it('should handle null input', () => {
    expect(() => calculateTotal(null)).toThrow('Items must be an array');
  });
});
```

# TypeScript Example

```ts
// Mock dependencies before imports
jest.mock('../api/userService', () => ({
  fetchUser: jest.fn(),
}));

// Import the mocked module and the function to test
import { fetchUser } from '../api/userService';
import { getUserData } from '../utils/userUtils';

// Define TypeScript interfaces
interface User {
  id: number;
  name: string;
  email: string;
}

describe('getUserData', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  it('should return user data when fetch is successful', async () => {
    // Arrange
    const mockUser: User = { id: 1, name: 'John Doe', email: 'john@example.com' };
    (fetchUser as jest.Mock).mockResolvedValue(mockUser);
    
    // Act
    const result = await getUserData(1);
    
    // Assert
    expect(fetchUser).toHaveBeenCalledWith(1);
    expect(result).toEqual(mockUser);
  });

  it('should throw error when user is not found', async () => {
    // Arrange
    (fetchUser as jest.Mock).mockResolvedValue(null);
    
    // Act & Assert
    await expect(getUserData(999)).rejects.toThrow('User not found');
  });

  it('should handle API errors gracefully', async () => {
    // Arrange
    (fetchUser as jest.Mock).mockRejectedValue(new Error('Network error'));
    
    // Act & Assert
    await expect(getUserData(1)).rejects.toThrow('Failed to fetch user: Network error');
  });
});
```

# TypeScript Mixin Testing (ts-mixer)

For packages using `ts-mixer` (like `@card-stack/core`), test mixin composition:

```ts
import { Card, CardSet, Mix } from '@card-stack/core';

describe('card', () => {
  // Create test class extending mixin
  class TestCard extends Mix(Card) {
    static __reset(): void {
      this.instances.clear();
    }
  }

  beforeEach(() => {
    TestCard.__reset();
  });

  afterEach(() => {
    TestCard.__reset();
  });

  it('is Indexable', () => {
    const card = new TestCard();
    expect(isIndexable(card)).toBe(true);
  });

  it('takes parent', () => {
    class TestCardSet extends Mix(CardSet) {}
    const cardSet = new TestCardSet();
    const card = new TestCard(cardSet);
    expect(card.parent).toBe(cardSet);
  });
});
```

# React Component Testing

For testing React components (e.g., in `@lellimecnar/ui`), use React Testing Library:

```ts
import { render, screen } from '@testing-library/react';
import { Button } from '@lellimecnar/ui/button';

describe('Button', () => {
  it('renders with correct text', () => {
    render(<Button>Click me</Button>);
    expect(screen.getByText('Click me')).toBeInTheDocument();
  });

  it('applies variant classes correctly', () => {
    const { container } = render(<Button variant="destructive">Delete</Button>);
    const button = container.querySelector('button');
    expect(button).toHaveClass('bg-destructive');
  });

  it('handles click events', () => {
    const handleClick = jest.fn();
    render(<Button onClick={handleClick}>Click</Button>);
    screen.getByText('Click').click();
    expect(handleClick).toHaveBeenCalledTimes(1);
  });
});
```

# Jest Configuration

Use the shared Jest config package when available:

```javascript
// jest.config.js
module.exports = require('@lellimecnar/jest-config/jest-preset');

// Or for browser/React components:
module.exports = require('@lellimecnar/jest-config/browser/jest-preset');
```

# Coverage Requirements

Configure coverage thresholds in Jest config:

```javascript
module.exports = {
  ...require('@lellimecnar/jest-config/jest-preset'),
  collectCoverageFrom: ['src/**/*.{ts,tsx}', '!src/**/*.spec.ts'],
  coverageThreshold: {
    global: {
      branches: 80,
      functions: 80,
      lines: 80,
      statements: 80,
    },
  },
};
```

# Monorepo Testing Patterns

- Use workspace package names in imports: `import { format } from '@lellimecnar/utils'`
- Mock workspace dependencies when needed: `jest.mock('@lellimecnar/utils')`
- Run tests for specific packages: `pnpm --filter @card-stack/core test`
- Use `test:watch` for development: `pnpm --filter @card-stack/core test:watch`
- Turborepo will cache test results based on inputs and outputs